trigger:
  - development
  - master
  - feature/CA3

pool:
  vmImage: 'ubuntu-latest'  # This will use an Ubuntu-based build agent

jobs:
  # Build Job
  - job: Build
    steps:
      # Step 1: Set up Python version (e.g., Python 3.x)
      - task: UsePythonVersion@0
        inputs:
          versionSpec: '3.x'  # Specify the Python version, you can use '3.x' or '3.9' for instance
          addToPath: true  # Ensures Python is added to PATH for subsequent steps

      # Step 2: Install dependencies from your custom 'dependencies.txt' (previously requirements.txt)
      - script: |
          pip install -r dependencies.txt  # Installing dependencies from your custom text file
        displayName: 'Install Dependencies from dependencies.txt'

      # Step 3: Static code analysis with Flake8
      - script: |
          pip install flake8  # Install flake8 for static code analysis
          flake8 .  # Run flake8 on your project directory to check code style issues
        displayName: 'Run Static Code Analysis with Flake8'

      # Step 4: Run Unit Tests with pytest and Track Code Coverage
      - script: |
          pip install pytest  # Install pytest for unit testing
          pip install coverage  # Install coverage for code coverage analysis
          pytest --maxfail=1 --disable-warnings -q --tb=short --junitxml=pytest_results.xml  # Run tests and generate XML results
          coverage run -m pytest  # Run the tests and track code coverage
          coverage xml -o coverage.xml  # Generate the coverage.xml file for Azure DevOps to use
          coverage report  # Print coverage results to the console
        displayName: 'Run Unit Tests with pytest and Track Code Coverage'

      # Step 5: Publish code coverage results (for Azure DevOps UI integration)
      - task: PublishCodeCoverageResults@2  # Use version 2 as version 1 is deprecated
        inputs:
          codeCoverageTool: 'Cobertura'  # Specify the tool to use (coverage.py)
          summaryFileLocation: '$(Build.SourcesDirectory)/coverage.xml'  # Path to the generated coverage.xml
          reportDirectory: '$(Build.ArtifactStagingDirectory)'  # Directory to store the results
        displayName: 'Publish Code Coverage Results'

      # Step 6: Publish test results (for Azure DevOps UI integration)
      - task: PublishTestResults@2
        inputs:
          testResultsFiles: '**/pytest_results.xml'  # Use the generated XML file for test results
          testRunTitle: 'Unit Tests Results'
        displayName: 'Publish Unit Test Results'

      # Step 7: Build Artifact
      - script: |
          mkdir build-output  # Create a directory for the artifact
          cp -r * build-output/  # Copy all project files into the directory
          zip -r build-output/artifact.zip build-output/  # Package the directory into a zip file
          ls -l build-output/  # List files to confirm artifact.zip exists
        displayName: 'Build Artifact'


      # Step 8: Upload Artifact
      - task: PublishBuildArtifacts@1
        inputs:
          artifactName: 'build-artifact'
          path: build-output/  # Upload the entire directory containing artifact.zip
          publishLocation: 'Container'
        displayName: 'Upload Artifact'

  # Test Job (Runs after Build)
  - job: Test
    dependsOn: Build
    condition: succeeded()  # Proceed only if Build job succeeds
    steps:
      # Step 1: Download Artifact
      - task: DownloadBuildArtifacts@0
      inputs:
        artifactName: 'build-artifact'  # Must match the artifactName in the Build Job
        downloadPath: $(Pipeline.Workspace)/artifacts  # Ensure it downloads to a known directory
      displayName: 'Download Artifact'

      # Step 2: Verify Artifact Download
      - script: |
          ls $(Pipeline.Workspace)/artifacts/  # Verify the artifact.zip exists
        displayName: 'Verify Artifact Download'

      # Step 3: Run Unit Tests (optional repeat)
      - script: |
          pytest tests/  # Run tests again if needed
        displayName: 'Run Unit Tests'

  # Deployment Job to Test (Requires Environment Approval)
  - deployment: DeployToTest
    environment: 'Test'  # This will require approval for deploying to Test environment
    dependsOn: Test
    condition: succeeded()  # Proceed only if Test job succeeds
    strategy:
      runOnce:
        deploy:
          steps:
            - script: |
                echo "Deploying to Test"
              displayName: 'Deploy to Test'

  # Deployment Job to Production (Requires Environment Approval)
  - deployment: DeployToProd
    environment: 'Production'  # This will require approval for deploying to Production environment
    dependsOn: DeployToTest
    condition: succeeded()  # Proceed only if DeployToTest succeeds
    strategy:
      runOnce:
        deploy:
          steps:
            - script: |
                echo "Deploying to Production"
              displayName: 'Deploy to Production'